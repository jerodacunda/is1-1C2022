

----STARTUP---- (16 June 2022 19:26:50) as /home/clinux01/Escritorio/inge1/linux64/CuisUniversity-5301.image!


----End fileIn of /home/clinux01/Escritorio/inge1/2022-1c/09-CustomerImporter/CustomerImporter.st----!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:19:03'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:19:04'!
PASSED!
!ImportTest methodsFor: 'nil' stamp: 'AF 6/16/2022 20:21:31'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:24:10' prior: 50519517!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:24:34' prior: 50519558!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'AF 6/16/2022 20:24:34'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:24:45' prior: 50519599!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:24:55' prior: 50519252!
test01Import

	Customer importCustomers. 
	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:24:58'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:25:06' prior: 50519687!
test01Import

	self importCustomers. 
	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:25:08'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:25:08'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:31:27' prior: 50519695!
test01Import

	self importCustomers. 
	
	
	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:31:56' prior: 50519706!
test01Import

	self importCustomers. 
	
	session.
	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:33:09' prior: 50519712!
test01Import

	| allCustomers |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:33:12'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:33:13'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:35:25' prior: 50519718!
test01Import

	| allCustomers |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	session select: [ :aCustomer | aCustomer ] ofType: 
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:36:06' prior: 50519732!
test01Import

	| allCustomers |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	session select: [ :aCustomer | aCustomer ] ofType: Customer. 
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:38:29' prior: 50519743!
test01Import

	| allCustomers customer1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: customer1.
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:39:04' prior: 50519754!
test01Import

	| allCustomers customer1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:39:05'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:40:18' prior: 50519647!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:40:21'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:40:22'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:41:00' prior: 50519769!
test01Import

	| allCustomers customer1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:41:01'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:41:02'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:41:02'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:41:03'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:42:19' prior: 50519832!
test01Import

	| allCustomers customer1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber 
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:42:20'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:42:28' prior: 50519859!
test01Import

	| allCustomers customer1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:42:29'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:42:30'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:42:42'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:42:43'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:44:22' prior: 50519883!
test01Import

	| allCustomers customer1 allAdresses |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	allAdresses _ session selectAllOfType:  Address.
	
	self assert: 3 equals: allAdresses size.

	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:44:27'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:44:42'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:45:17' prior: 50519914!
test01Import

	| allCustomers customer1 allAdresses |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	allAdresses _ session selectAllOfType: Address.
	
	self assert: 3 equals: allAdresses size.

	
	session commit.
	session close.! !

(self objectsOfType: aType)!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:48:40' prior: 50519944!
test01Import

	| allCustomers customer1 allAdresses |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	allAdresses _ customer1 addresses.
	
	self assert: 3 equals: allAdresses size.

	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:48:43'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:48:52' prior: 50519970!
test01Import

	| allCustomers customer1 allAdresses |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	allAdresses _ customer1 addresses.
	
	self assert: 2 equals: allAdresses size.

	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:48:54'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:48:54'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:52:36' prior: 50519997!
test01Import

	| allCustomers customer1 allAdresses customerAddress1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 addresses detect: [:anAddress | anAddress ].
	
	self assert: 2 equals: allAdresses size.

	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:54:17' prior: 50520027!
test01Import

	| allCustomers customer1 allAdresses customerAddress1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 addresses detect: [:anAddress | (anAddress streetName = 'San Martin') and: [anAddress ]].
	
	self assert: 2 equals: allAdresses size.

	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:58:53' prior: 50520053!
test01Import

	| allCustomers customer1 allAdresses customerAddress1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 addresses detect: [:anAddress | (anAddress streetName = 'San Martin') and: [anAddress streetNumber = 3322]].
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.

	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:58:55'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 20:59:32' prior: 50519788!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:59:35'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:59:36'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:59:44'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 20:59:45'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:04:17' prior: 50520081!
test01Import

	| allCustomers customer1 allAdresses customerAddress1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 named: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.

	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:05:06' prior: 50520168!
test01Import

	| allCustomers customer1 customerAddress1 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.

	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:05:11'!
ERROR!
!Customer methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:05:17'!
giveMeAnAddressAt: aSmallInteger namedFFFFFFFFFFFFFFF: aString 
	self shouldBeImplemented.! !
!Customer methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:06:23' prior: 50520238!
giveMeAnAddressAt: aSmallInteger namedFFFFFFFFFFFFFFF: aString 
	
	^addresses detect: [:anAddress | (anAddress streetName = aString) and: [anAddress streetNumber = aSmallInteger]].! !
!Customer methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:06:29' prior: 50520244!
giveMeAnAddressAt: aStreetNumber namedFFFFFFFFFFFFFFF: aString 
	
	^addresses detect: [:anAddress | (anAddress streetName = aString) and: [anAddress streetNumber = aStreetNumber]].! !
!Customer methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:06:42' prior: 50520253!
giveMeAnAddressAt: aStreetNumber namedFFFFFFFFFFFFFFF: aStreetName 
	
	^addresses detect: [:anAddress | (anAddress streetName = aStreetName) and: [anAddress streetNumber = aStreetNumber]].! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:06:55'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:06:56'!
PASSED!
!Customer methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:08:55' prior: 50520262!
giveMeAnAddressAt: aStreetNumber namedFFFFFFFFFFFFFFF: aStreetName 
	
	^addresses detect: [:anAddress | (anAddress isNamed: aStreetName withNumber: aStreetNumber )].! !
!Customer methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:09:01' prior: 50520276!
giveMeAnAddressAt: aStreetNumber namedFFFFFFFFFFFFFFF: aStreetName 
	
	^addresses detect: [:anAddress | anAddress isNamed: aStreetName withNumber: aStreetNumber ].! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:09:08'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:09:09'!
ERROR!
!Address methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:09:15'!
isNamed: aString withNumber: aSmallInteger 
	self shouldBeImplemented.! !
!Address methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:09:43' prior: 50520298!
isNamed: aString withNumber: aSmallInteger 
	
	(streetName = aString) and: [streetNumber = aSmallInteger ]! !
!Address methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:10:22' prior: 50520304!
isNamed: aStreetName withNumber: aStreetNumber 
	
	(streetName = aStreetName) and: [streetNumber = aStreetNumber ]! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:10:24'!
ERROR!
!Address methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:10:35' prior: 50520311!
isNamed: aStreetName withNumber: aStreetNumber 
	
	^(streetName = aStreetName) and: [streetNumber = aStreetNumber ]! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:10:37'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:12:17' prior: 50520202!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress1 streetName.
	self assert: 888 equals: customerAddress1 streetNumber.
	self assert: 1122 equals: customerAddress1 zipCode.
	self assert: 'Florida' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.	

	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:12:28' prior: 50520330!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'BsAs' equals: customerAddress2 province.	

	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:12:30'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:12:50' prior: 50520376!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	

	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:13:12'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:13:13'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:15:24'!
m1

	^ StandardFileStream new open: 'input.txt' forWrite: false! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:15:24' prior: 50520119!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := self m1.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:15:44' prior: 50520482!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !

!methodRemoval: ImportTest #m1 stamp: 'AF 6/16/2022 21:15:46'!
m1

	^ StandardFileStream new open: 'input.txt' forWrite: false!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:16:27'!
importCustomers: aStream

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:16:27' prior: 50520425!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: (StandardFileStream new open: 'input.txt' forWrite: false). 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	

	
	session commit.
	session close.! !

!methodRemoval: ImportTest #importCustomers stamp: 'AF 6/16/2022 21:16:27'!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].


	inputStream close.
	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:16:27' prior: 50520563!
importCustomers: aStream

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := aStream.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:16:37'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:16:38'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:18:02'!
m1

	^ StandardFileStream new open: 'input.txt' forWrite: false! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:18:02' prior: 50520603!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: (self m1). 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	

	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:18:46' prior: 50520733!
m1

	^ Stream on:'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:18:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:18:47'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:19:04' prior: 50520786!
m1

	^ ReadStream on:'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:19:04'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:19:49' prior: 50520739!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self m1. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	

	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:20:00'!
openStream

	^ ReadStream on:'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:20:00' prior: 50520812!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	

	
	session commit.
	session close.! !

!methodRemoval: ImportTest #m1 stamp: 'AF 6/16/2022 21:20:00'!
m1

	^ ReadStream on:'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:29:18' overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:29:18' prior: 50520690!
importCustomers: aStream

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := aStream.
	self setUp.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:29:48' prior: 50520929!
importCustomers: aStream

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := aStream.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:30:27'!
extractMethod

	session commit.
	session close! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:30:27' prior: 50520867!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	

	
	self extractMethod.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:30:49' overrides: 16961402!
tearDown

	session commit.
	session close! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:30:49' prior: 50521005!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	

	
	self tearDown.! !

!methodRemoval: ImportTest #extractMethod stamp: 'AF 6/16/2022 21:30:49'!
extractMethod

	session commit.
	session close!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:31:27' prior: 50520922 overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:32:08' prior: 50521057!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:32:14'!
PASSED!

!classDefinition: #ImportClients category: 'CustomerImporter' stamp: 'AF 6/16/2022 21:35:19'!
Object subclass: #ImportClients
	instanceVariableNames: 'session stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportClients class methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:35:19'!
importClients: aSession from: aStream
	^self new initializeImportClients: aSession from: aStream! !
!ImportClients methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:35:19'!
initializeImportClients: aSession from: aStream
	session := aSession.
	stream := aStream.! !
!ImportClients methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:35:19' overrides: 16902254!
value

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := stream.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].


	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:35:19' prior: 50520965!
importCustomers: aStream
	(ImportClients importClients: session from: aStream) value! !
!ImportClients methodsFor: 'initialization' stamp: 'AF 6/16/2022 21:35:56'!
initializeFrom: aSession ImportClients: aStream
	session := aSession.
	stream := aStream.! !
!ImportClients class methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:35:56' prior: 50521171!
importClients: aSession from: aStream
	^self new initializeFrom: aSession ImportClients: aStream! !

!methodRemoval: ImportClients #initializeImportClients:from: stamp: 'AF 6/16/2022 21:35:56'!
initializeImportClients: aSession from: aStream
	session := aSession.
	stream := aStream.!
!ImportClients class methodsFor: 'instance creation' stamp: 'AF 6/16/2022 21:36:18'!
from: aSession importClients: aStream
	^self new initializeFrom: aSession ImportClients: aStream! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:36:18' prior: 50521219!
importCustomers: aStream
	(ImportClients from: session importClients: aStream) value! !

!methodRemoval: ImportClients class #importClients:from: stamp: 'AF 6/16/2022 21:36:18'!
importClients: aSession from: aStream
	^self new initializeFrom: aSession ImportClients: aStream!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:36:37'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:36:38'!
PASSED!
!ImportClients methodsFor: 'initialization' stamp: 'AF 6/16/2022 21:37:10'!
initializeFrom: aSession importClientsTo: aStream
	session := aSession.
	stream := aStream.! !
!ImportClients class methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:37:10' prior: 50521244!
from: aSession importClients: aStream
	^self new initializeFrom: aSession importClientsTo: aStream! !

!methodRemoval: ImportClients #initializeFrom:ImportClients: stamp: 'AF 6/16/2022 21:37:10'!
initializeFrom: aSession ImportClients: aStream
	session := aSession.
	stream := aStream.!
!ImportClients class methodsFor: 'instance creation' stamp: 'AF 6/16/2022 21:37:19'!
from: aSession importClientsTo: aStream
	^self new initializeFrom: aSession importClientsTo: aStream! !

!methodRemoval: ImportClients class #from:importClients: stamp: 'AF 6/16/2022 21:37:19'!
from: aSession importClients: aStream
	^self new initializeFrom: aSession importClientsTo: aStream!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:37:22'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:37:38' prior: 50521251!
importCustomers: aStream
	(ImportClients from: session importClientsTo: aStream) value! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:37:40'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:41:49'!
m1: customerAddress1

	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:41:49' prior: 50521115!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self m1: customerAddress1.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:42:40'!
m1: customerAddress1 streetNqme: streetName 

	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:42:40' prior: 50521322!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self m1: customerAddress1 streetNqme: 'San Martin'.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	! !

!methodRemoval: ImportTest #m1: stamp: 'AF 6/16/2022 21:42:40'!
m1: customerAddress1

	self assert: 'San Martin' equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:42:40' prior: 50521359!
m1: customerAddress1 streetNqme: streetName 

	self assert: streetName equals: customerAddress1 streetName.
	self assert: 3322 equals: customerAddress1 streetNumber.
	self assert: 1636 equals: customerAddress1 zipCode.
	self assert: 'Olivos' equals: customerAddress1 town.
	self assert: 'BsAs' equals: customerAddress1 province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:42:54' prior: 50521423!
m1: aCustomerAddress streetNqme: streetName 

	self assert: streetName equals: aCustomerAddress streetName.
	self assert: 3322 equals: aCustomerAddress streetNumber.
	self assert: 1636 equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:43:25'!
assert: aCustomerAddress isNamed: streetName 

	self assert: streetName equals: aCustomerAddress streetName.
	self assert: 3322 equals: aCustomerAddress streetNumber.
	self assert: 1636 equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:43:25' prior: 50521373!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin'.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	! !

!methodRemoval: ImportTest #m1:streetNqme: stamp: 'AF 6/16/2022 21:43:25'!
m1: aCustomerAddress streetNqme: streetName 

	self assert: streetName equals: aCustomerAddress streetName.
	self assert: 3322 equals: aCustomerAddress streetNumber.
	self assert: 1636 equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:43:55'!
assert: aCustomerAddress isNamed: streetName at: aStreetNumber  

	self assert: streetName equals: aCustomerAddress streetName.
	self assert: 3322 equals: aCustomerAddress streetNumber.
	self assert: 1636 equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:43:55' prior: 50521464!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin' at: 3322.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	! !

!methodRemoval: ImportTest #assert:isNamed: stamp: 'AF 6/16/2022 21:43:55'!
assert: aCustomerAddress isNamed: streetName 

	self assert: streetName equals: aCustomerAddress streetName.
	self assert: 3322 equals: aCustomerAddress streetNumber.
	self assert: 1636 equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:43:55' prior: 50521515!
assert: aCustomerAddress isNamed: streetName at: aStreetNumber  

	self assert: streetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: 1636 equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:44:04' prior: 50521581!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber  

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: 1636 equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:44:53'!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber with: aZipCode   

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: 1636 equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:44:54' prior: 50521529!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin' at: 3322 with: 1636.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	! !

!methodRemoval: ImportTest #assert:isNamed:at: stamp: 'AF 6/16/2022 21:44:54'!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber  

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: 1636 equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:44:54' prior: 50521610!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber with: aZipCode   

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: aZipCode equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:45:42'!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber with: aZipCode inTown: aTown    

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: aZipCode equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:45:42' prior: 50521625!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin' at: 3322 with: 1636 inTown: 'Olivos'.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	! !

!methodRemoval: ImportTest #assert:isNamed:at:with: stamp: 'AF 6/16/2022 21:45:42'!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber with: aZipCode   

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: aZipCode equals: aCustomerAddress zipCode.
	self assert: 'Olivos' equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:45:42' prior: 50521693!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber with: aZipCode inTown: aTown    

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: aZipCode equals: aCustomerAddress zipCode.
	self assert: aTown equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:46:06'!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber with: aZipCode inTown: aTown inProvince: aProvince     

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: aZipCode equals: aCustomerAddress zipCode.
	self assert: aTown equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:46:06' prior: 50521709!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin' at: 3322 with: 1636 inTown: 'Olivos' inProvince: 'BsAs'.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.

	self assert: 'Maipu' equals: customerAddress2 streetName.
	self assert: 888 equals: customerAddress2 streetNumber.
	self assert: 1122 equals: customerAddress2 zipCode.
	self assert: 'Florida' equals: customerAddress2 town.
	self assert: 'Buenos Aires' equals: customerAddress2 province.	! !

!methodRemoval: ImportTest #assert:isNamed:at:with:inTown: stamp: 'AF 6/16/2022 21:46:06'!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber with: aZipCode inTown: aTown    

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: aZipCode equals: aCustomerAddress zipCode.
	self assert: aTown equals: aCustomerAddress town.
	self assert: 'BsAs' equals: aCustomerAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:46:06' prior: 50521778!
assert: aCustomerAddress isNamed: aStreetName at: aStreetNumber with: aZipCode inTown: aTown inProvince: aProvince     

	self assert: aStreetName equals: aCustomerAddress streetName.
	self assert: aStreetNumber equals: aCustomerAddress streetNumber.
	self assert: aZipCode equals: aCustomerAddress zipCode.
	self assert: aTown equals: aCustomerAddress town.
	self assert: aProvince equals: aCustomerAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:47:28' prior: 50521794!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin' at: 3322 with: 1636 inTown: 'Olivos' inProvince: 'BsAs'.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.
	
	self assert: customerAddress2 isNamed: 'Maipu' at: 888 with: 1122 inTown: 'Florida' inProvince: 'Buenos Aires'.

! !

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:47:29'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'AF 6/16/2022 21:47:30'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:47:59' prior: 50521867!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	
	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin' at: 3322 with: 1636 inTown: 'Olivos' inProvince: 'BsAs'.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.
	
	self assert: customerAddress2 isNamed: 'Maipu' at: 888 with: 1122 inTown: 'Florida' inProvince: 'Buenos Aires'.

! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:48:19'!
assertJJJJJJ: customer1

	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:48:19' prior: 50521907!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	
	self assertJJJJJJ: customer1.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin' at: 3322 with: 1636 inTown: 'Olivos' inProvince: 'BsAs'.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.
	
	self assert: customerAddress2 isNamed: 'Maipu' at: 888 with: 1122 inTown: 'Florida' inProvince: 'Buenos Aires'.

! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:49:10'!
assertJJJJJJ: customer1 firstNameIs: aFirstName 

	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:49:10' prior: 50521953!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	
	self assertJJJJJJ: customer1 firstNameIs: 'Pepe'.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin' at: 3322 with: 1636 inTown: 'Olivos' inProvince: 'BsAs'.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.
	
	self assert: customerAddress2 isNamed: 'Maipu' at: 888 with: 1122 inTown: 'Florida' inProvince: 'Buenos Aires'.

! !

!methodRemoval: ImportTest #assertJJJJJJ: stamp: 'AF 6/16/2022 21:49:10'!
assertJJJJJJ: customer1

	self assert: 'Pepe' equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:49:10' prior: 50521982!
assertJJJJJJ: customer1 firstNameIs: aFirstName 

	self assert: aFirstName equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:49:33'!
assertJJJJJJ: customer1 firstNameIs: aFirstName lastNameIs: aLastName  

	self assert: aFirstName equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:49:33' prior: 50521994!
test01Import

	| allCustomers customer1 customerAddress1 customerAddress2 |
	self importCustomers: self openStream. 
	
	allCustomers _ session selectAllOfType: Customer.
	
	self assert: 2 equals: allCustomers size.
	customer1 _ (session select: [ :aCustomer | (aCustomer identificationType = 'D') and: [aCustomer identificationNumber = '22333444']] ofType: Customer) anyOne.
	
	self assertJJJJJJ: customer1 firstNameIs: 'Pepe' lastNameIs: 'Sanchez'.
	
	customerAddress1 _ customer1 giveMeAnAddressAt: 3322 namedFFFFFFFFFFFFFFF: 'San Martin' .
	
	self assert: customerAddress1 isNamed: 'San Martin' at: 3322 with: 1636 inTown: 'Olivos' inProvince: 'BsAs'.
	
	customerAddress2 _ customer1 giveMeAnAddressAt: 888 namedFFFFFFFFFFFFFFF: 'Maipu'.
	
	self assert: customerAddress2 isNamed: 'Maipu' at: 888 with: 1122 inTown: 'Florida' inProvince: 'Buenos Aires'.

! !

!methodRemoval: ImportTest #assertJJJJJJ:firstNameIs: stamp: 'AF 6/16/2022 21:49:33'!
assertJJJJJJ: customer1 firstNameIs: aFirstName 

	self assert: aFirstName equals: customer1 firstName.
	self assert: 'Sanchez' equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'AF 6/16/2022 21:49:33' prior: 50522046!
assertJJJJJJ: customer1 firstNameIs: aFirstName lastNameIs: aLastName  

	self assert: aFirstName equals: customer1 firstName.
	self assert: aLastName equals: customer1 lastName.
	self assert: 'D' equals: customer1 identificationType .
	self assert: '22333444' equals: customer1 identificationNumber! !

----QUIT----(16 June 2022 21:49:49) CuisUniversity-5301.image priorSource: 6002664!